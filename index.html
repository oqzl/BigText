<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>BigText</title>
  
  <!-- PWA manifest -->
  <link rel="manifest" href="manifest.json" />
  
  <!-- iOS specific meta tags -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="BigText" />
  
  <!-- Icons for various platforms -->
  <link rel="apple-touch-icon" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />
  
  <!-- Theme color -->
  <meta name="theme-color" content="#0b0b0b" />
  <style>
    :root {
      --bg: #0b0b0b;
      --ui: #0f1720;
      --fg: #fff;
      --muted: #9aa4b2;
      --viewport-bottom-offset: 0px;
      --controls-stack-height: 0px;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "メイリオ", sans-serif;
      background: var(--bg);
      color: var(--fg)
    }

    .topbar {
      position: fixed;
      left: 0;
      right: 0;
      top: env(safe-area-inset-top);
      height: 72px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px 8px 8px 8px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
      box-sizing: border-box;
      z-index: 20
    }
    
    .topbar-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .app-title {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: var(--fg);
      white-space: nowrap;
    }

    .controls {
      display: flex;
      gap: 8px;
      flex: 1;
      align-items: stretch;
    }

    .input-stack {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    }

    textarea#input {
      flex: 1;
      min-height: 48px;
      max-height: 160px;
      border-radius: 8px;
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(255, 255, 255, 0.02);
      color: var(--fg);
      resize: vertical;
      font-size: 16px
    }

    button {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 14px
    }

    .secondary-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    .secondary-actions button {
      flex: 0 0 auto;
    }

    .hint-message {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
    }

    .hint-message[hidden] {
      display: none;
    }

    .actions {
      display: flex;
      gap: 8px;
    }

    main {
      position: fixed;
      top: calc(env(safe-area-inset-top) + 72px);
      left: 0;
      right: 0;
      bottom: var(--controls-stack-height);
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center
    }

    canvas {
      display: block;
      max-width: 100%;
      height: 100%;
    }

    .bottom-hint {
      position: fixed;
      left: 12px;
      bottom: 12px;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      z-index: 25;
    }

    .hint {
      color: var(--muted);
      font-size: 13px;
    }

    .speak {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.12);
      color: #e5e7eb;
      padding: 10px 16px;
      border-radius: 9999px;
      font-size: 14px;
      backdrop-filter: blur(4px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }

    .speak.floating {
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
    }

    body.view-mode main {
      top: env(safe-area-inset-top);
    }

    @media (max-width: 640px) {
      .topbar {
        top: auto;
        height: auto;
        bottom: calc(env(safe-area-inset-bottom) + var(--viewport-bottom-offset));
        padding: 12px 12px calc(12px + env(safe-area-inset-bottom));
        background: linear-gradient(0deg, rgba(255, 255, 255, 0.04), transparent);
        align-items: stretch;
      }

      .topbar-row {
        flex-direction: column;
        align-items: stretch;
      }

      .controls {
        width: 100%;
        flex-direction: column;
      }

      .actions {
        width: 100%;
      }

      .actions button {
        flex: 1;
      }

      .secondary-actions {
        justify-content: stretch;
      }

      .secondary-actions button {
        flex: 1;
      }

      main {
        top: env(safe-area-inset-top);
      }

      body.view-mode main {
        bottom: 0;
      }
    }

    @media (max-width:420px) {
      .topbar {
        /* height: 80px */
      }

      textarea#input {
        font-size: 15px
      }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <h1 class="app-title">BigText</h1>
    <div class="topbar-row">
      <div class="controls">
        <div class="input-stack">
          <textarea id="input" placeholder="Type something bold. Line breaks are allowed.">Make it bold.
Make it unforgettable.</textarea>
          <div class="secondary-actions">
            <button id="btnHint" type="button" aria-controls="hintMessage" aria-expanded="false">Hint</button>
            <button id="btnSpeak" class="speak" type="button" title="Speak the text aloud">Speak</button>
          </div>
          <div id="hintMessage" class="hint-message" hidden role="status">Switch to View mode to fill the screen. Tap the canvas to edit again.</div>
        </div>
      </div>
      <div class="actions">
        <button id="btnView" type="button">View</button>
        <button id="btnSave" type="button">Save PNG</button>
      </div>
    </div>
  </div>
  <main>
    <canvas id="canvas"></canvas>
  </main>
  <div class="bottom-hint">
    <div class="hint">Tap the canvas to edit</div>
  </div>

  <script>
    /* 実用重視。プライベート関数は先頭にアンダースコア */
    const _canvas = document.getElementById('canvas');
    const _ctx = _canvas.getContext('2d');
    const _input = document.getElementById('input');
    const _btnView = document.getElementById('btnView');
    const _btnSave = document.getElementById('btnSave');
    const _btnSpeak = document.getElementById('btnSpeak');
    const _btnHint = document.getElementById('btnHint');
    const _topbar = document.querySelector('.topbar');
    const _secondaryActions = document.querySelector('.secondary-actions');
    const _hintMessage = document.getElementById('hintMessage');
    const _bottomHint = document.querySelector('.bottom-hint');
    const _hintLabel = document.querySelector('.hint');
    const _rootStyle = document.documentElement.style;
    const _mobileQuery = window.matchMedia('(max-width: 640px)');

    let _mode = 'edit'; // 'edit' or 'view'
    let _lastText = _input.value || '';
    let _devicePixelRatio = Math.max(window.devicePixelRatio || 1, 1);
    const _padding = 24; // canvas 内余白
    const _lineHeightRatioBase = 1.02; // 単一行の行間比
    const _lineHeightRatioMulti = 1.18; // 複数行時に少し広げる
    const _fontFamily = 'sans-serif';

    /* キャンバスリサイズ（高DPI対応） */
    function _resizeCanvas() {
      const rect = _canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width * _devicePixelRatio));
      const h = Math.max(1, Math.floor(rect.height * _devicePixelRatio));
      if (_canvas.width !== w || _canvas.height !== h) {
        _canvas.width = w; _canvas.height = h;
        _ctx.setTransform(_devicePixelRatio, 0, 0, _devicePixelRatio, 0, 0);
      }
    }

    /* テキスト行に分割（改行コードを正規化してから '\n' で分割）。空行はスペース1つに */
    function _toLines(text) {
      if (typeof text !== 'string') return [' '];
      const normalized = text.replace(/\r\n?|\u2028|\u2029/g, '\n'); // CRLF/CR/LS/PS → \n
      return normalized.split('\n').map(l => l === '' ? ' ' : l);
    }

    /* 指定フォントサイズでテキストが収まるか判定 */
    function _fits(fontSize, lines, cw, ch) {
      _ctx.font = `${fontSize}px ${_fontFamily}`;
      const maxW = cw - _padding * 2;
      for (let line of lines) {
        const m = _ctx.measureText(line);
        if (m.width > maxW + 1) return false;
      }
      let ascent = 0, descent = 0;
      try {
        const m = _ctx.measureText(lines[0] || 'M');
        ascent = m.actualBoundingBoxAscent || fontSize * 0.8;
        descent = m.actualBoundingBoxDescent || fontSize * 0.2;
      } catch (e) { ascent = fontSize * 0.8; descent = fontSize * 0.2; }
      const lineHeightRatio = (lines.length > 1) ? _lineHeightRatioMulti : _lineHeightRatioBase;
      const lineH = (ascent + descent) * lineHeightRatio;
      const totalH = lineH * lines.length;
      return totalH <= (ch - _padding * 2) + 1;
    }

    /* 最大フォントサイズを二分探索で求める */
    function _computeMaxFontSize(lines, cw, ch) {
      if (!lines || lines.length === 0) return 16;
      let low = 4, high = 4000;
      if (lines.join('\n').trim() === '') return 48; // 空白のみ
      for (let i = 0; i < 40; i++) {
        const mid = Math.floor((low + high) / 2);
        if (_fits(mid, lines, cw, ch)) low = mid; else high = mid;
        if (high - low <= 1) break;
      }
      return low;
    }

    /* キャンバスにテキストを描画 */
    function _drawText() {
      _resizeCanvas();
      const rect = _canvas.getBoundingClientRect();
      const cw = rect.width, ch = rect.height;
      const lines = _toLines(_lastText);
      const size = _computeMaxFontSize(lines, cw, ch);
      _ctx.clearRect(0, 0, _canvas.width / _devicePixelRatio, _canvas.height / _devicePixelRatio);
      const g = _ctx.createLinearGradient(0, 0, 0, ch);
      g.addColorStop(0, '#0b0b0b'); g.addColorStop(1, '#071018');
      _ctx.fillStyle = g; _ctx.fillRect(0, 0, cw, ch);
      _ctx.font = `${size}px ${_fontFamily}`;
      _ctx.textAlign = 'center'; _ctx.textBaseline = 'alphabetic';
      let ascent = 0, descent = 0;
      try { const m = _ctx.measureText(lines[0] || 'M'); ascent = m.actualBoundingBoxAscent || size * 0.8; descent = m.actualBoundingBoxDescent || size * 0.2; }
      catch (e) { ascent = size * 0.8; descent = size * 0.2; }
      const lineHeightRatio = (lines.length > 1) ? _lineHeightRatioMulti : _lineHeightRatioBase;
      const lineH = (ascent + descent) * lineHeightRatio;
      const totalH = lineH * lines.length;
      const verticalSpace = Math.max(0, ch - totalH);
      const startY = verticalSpace * 0.45 + ascent; // 中央より少し上
      const centerX = cw / 2;
      _ctx.lineWidth = Math.max(2, Math.floor(size * 0.06));
      _ctx.strokeStyle = 'rgba(0,0,0,0.6)';
      _ctx.fillStyle = '#ffffff';
      for (let i = 0; i < lines.length; i++) {
        const y = startY + i * lineH;
        _ctx.strokeText(lines[i], centerX, y);
        _ctx.fillText(lines[i], centerX, y);
      }
    }

    /* ===== レイアウト補助 ===== */
    function _keyboardOverlap() {
      if (!window.visualViewport) return 0;
      const vv = window.visualViewport;
      const layoutHeight = window.innerHeight;
      const overlap = layoutHeight - (vv.height + vv.offsetTop);
      return Math.max(0, overlap);
    }

    function _updateControlOffsets() {
      const overlap = _keyboardOverlap();
      _rootStyle.setProperty('--viewport-bottom-offset', `${overlap}px`);
      if (_mobileQuery.matches && _mode === 'edit') {
        const rect = _topbar.getBoundingClientRect();
        _rootStyle.setProperty('--controls-stack-height', `${rect.height + overlap}px`);
      } else {
        _rootStyle.setProperty('--controls-stack-height', '0px');
      }
    }

    function _relocateSpeakButtonToFloating() {
      if (_btnSpeak.parentElement !== _bottomHint) {
        _bottomHint.insertBefore(_btnSpeak, _hintLabel);
      }
      _btnSpeak.classList.add('floating');
    }

    function _relocateSpeakButtonToStack() {
      if (_btnSpeak.parentElement !== _secondaryActions) {
        _secondaryActions.appendChild(_btnSpeak);
      }
      _btnSpeak.classList.remove('floating');
    }

    function _closeHintMessage() {
      if (!_hintMessage.hasAttribute('hidden')) {
        _hintMessage.setAttribute('hidden', '');
      }
      _btnHint?.setAttribute('aria-expanded', 'false');
    }

    /* ===== Web Speech API 読み上げ ===== */
    let _voices = [];
    let _preferredVoice = null;
    let _speaking = false;
    function _refreshVoices() {
      if (!('speechSynthesis' in window)) return;
      _voices = speechSynthesis.getVoices();
      const preferredLangs = [];
      const navLang = (navigator.language || 'en-US').toLowerCase();
      preferredLangs.push(navLang);
      if (!navLang.startsWith('en')) preferredLangs.push('en-US', 'en');
      preferredLangs.push('ja-JP', 'ja');
      _preferredVoice = null;
      for (const lang of preferredLangs) {
        const match = _voices.find(v => v.lang && v.lang.toLowerCase().startsWith(lang));
        if (match) { _preferredVoice = match; break; }
      }
    }
    function _textForSpeech() {
      const normalized = (_lastText || '').replace(/\r\n?|\u2028|\u2029/g, '\n');
      return normalized.split('\n').map(s => s.trim()).filter(s => s.length > 0).join('. ');
    }
    function _speak() {
      if (!('speechSynthesis' in window)) {
        alert('Speech synthesis is not supported in this browser.');
        return;
      }
      try {
        speechSynthesis.cancel();
        if (_speaking) {
          _speaking = false;
          _btnSpeak.textContent = 'Speak';
        }
        const text = _textForSpeech();
        if (!text) {
          alert('Enter some text before using speech synthesis.');
          return;
        }
        const u = new SpeechSynthesisUtterance(text);
        if (_preferredVoice) { u.voice = _preferredVoice; u.lang = _preferredVoice.lang; }
        else { u.lang = navigator.language || 'en-US'; }
        u.rate = 1.0; u.pitch = 1.0;
        u.onstart = () => { _speaking = true; _btnSpeak.textContent = 'Stop'; };
        u.onend = () => { _speaking = false; _btnSpeak.textContent = 'Speak'; };
        u.onerror = () => { _speaking = false; _btnSpeak.textContent = 'Speak'; };
        speechSynthesis.speak(u);
      } catch (err) {
        console.error('Speech synthesis failed:', err);
        alert('Speech synthesis is blocked. Please open this page over HTTPS in a regular browser tab.');
      }
    }
    function _toggleSpeak() {
      if (_speaking) { speechSynthesis.cancel(); _speaking = false; _btnSpeak.textContent = 'Speak'; }
      else { _speak(); }
    }

    function _toggleHint() {
      if (_hintMessage.hasAttribute('hidden')) {
        _hintMessage.removeAttribute('hidden');
        _btnHint.setAttribute('aria-expanded', 'true');
      } else {
        _hintMessage.setAttribute('hidden', '');
        _btnHint.setAttribute('aria-expanded', 'false');
      }
    }

    /* ====== ファイル名生成（空白・改行→アンダースコア、拡張子は .png）====== */
    function _buildFileName(raw) {
      let s = String(raw ?? '');
      // 改行系を \n に統一
      s = s.replace(/\r\n?|\u2028|\u2029/g, '\n');
      // 半角/全角スペース・タブ・改行をアンダースコアに（1対1変換）
      s = s.replace(/[\u0020\u3000\t\n\r]/g, '_');
      // OSで不正になりうる文字は安全側で _ に
      s = s.replace(/[\\\/:\*?"<>\|#%]/g, '_');
      // 空なら既定名
      if (s.length === 0 || /^_*$/.test(s)) s = 'image';
      // 末尾に拡張子
      if (!/\.png$/i.test(s)) s += '.png';
      return s;
    }

    /* PNG 保存（Blobを直接ダウンロード） */
    function _savePNG() {
      const textNow = (_mode === 'view') ? _lastText : _input.value;
      const fileName = _buildFileName(textNow);
      if (_mode === 'view') _drawText(); else { _lastText = textNow; _drawText(); }
      _canvas.toBlob(blob => {
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName; // 指定どおり、文字列そのまま（空白・改行は_）+ .png
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url); // 即時解放（ブロックされにくい）
      }, 'image/png');
    }

    /* モード切替 */
    function _enterView() {
      _mode = 'view';
      document.body.classList.add('view-mode');
      _topbar.style.display = 'none';
      _hintLabel.style.display = 'block';
      _btnView.textContent = 'Edit';
      _lastText = _input.value;
      _drawText();
      _canvas.addEventListener('click', _onCanvasClickToEdit);
      _relocateSpeakButtonToFloating();
      _btnSpeak.textContent = _speaking ? 'Stop' : 'Speak';
      _closeHintMessage();
      _updateControlOffsets();
    }
    function _enterEdit() {
      _mode = 'edit';
      document.body.classList.remove('view-mode');
      _topbar.style.display = 'flex';
      _hintLabel.style.display = 'none';
      _btnView.textContent = 'View';
      _canvas.removeEventListener('click', _onCanvasClickToEdit);
      _relocateSpeakButtonToStack();
      if (_speaking) { speechSynthesis.cancel(); _speaking = false; }
      _btnSpeak.textContent = 'Speak';
      _closeHintMessage();
      // Clear canvas in edit mode
      _ctx.clearRect(0, 0, _canvas.width / _devicePixelRatio, _canvas.height / _devicePixelRatio);
      requestAnimationFrame(_updateControlOffsets);
    }
    function _onCanvasClickToEdit() { _enterEdit(); }

    /* イベント */
    _btnView.addEventListener('click', () => { if (_mode === 'edit') _enterView(); else _enterEdit(); });
    _btnSave.addEventListener('click', _savePNG);
    _btnHint.addEventListener('click', _toggleHint);
    _btnSpeak.addEventListener('click', _toggleSpeak);
    _input.addEventListener('input', () => {
      _lastText = _input.value;
      if (_mode === 'view') _drawText();
      requestAnimationFrame(_updateControlOffsets);
    });
    window.addEventListener('resize', () => {
      _updateControlOffsets();
      if (_mode === 'view') requestAnimationFrame(_drawText);
    });
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        _updateControlOffsets();
        if (_mode === 'view') _drawText();
      }, 120);
    });
    window.speechSynthesis?.addEventListener('voiceschanged', _refreshVoices);

    /* --- 簡易セルフテスト --- */
    function _assert(name, cond) { if (!cond) { console.error('[TEST FAIL]', name); } else { console.log('%c[TEST PASS]', 'color:#4ade80', name); } }
    function _runSelfTests() {
      console.group('Self Tests');
      _assert('toLines basic', JSON.stringify(_toLines('a\nb')) === JSON.stringify(['a', 'b']));
      _assert('toLines CRLF', JSON.stringify(_toLines('a\r\nb')) === JSON.stringify(['a', 'b']));
      _assert('toLines CR', JSON.stringify(_toLines('a\rb')) === JSON.stringify(['a', 'b']));
      _assert('toLines keep empty', JSON.stringify(_toLines('a\n\nb')) === JSON.stringify(['a', ' ', 'b']));
      _assert('toLines non-string', _toLines(null).length === 1 && _toLines(null)[0] === ' ');
      // 追加テスト: ファイル名
      _assert('buildFileName newline/space', _buildFileName('あ い\nう').startsWith('あ_い_う') && _buildFileName('あ い\nう').endsWith('.png'));
      _assert('buildFileName forbidden chars', _buildFileName('a/b\\c').indexOf('/') === -1 && _buildFileName('a/b\\c').indexOf('\\') === -1);
      _assert('buildFileName empty -> image.png', _buildFileName('   ').toLowerCase() === 'image.png');
      console.groupEnd();
    }

    /* 初期セットアップ */
    (function _init() {
      function _fitCanvasToParent() {
        const mainRect = document.querySelector('main').getBoundingClientRect();
        _canvas.style.width = mainRect.width + 'px';
        _canvas.style.height = mainRect.height + 'px';
        _resizeCanvas();
      }
      
      // Visual Viewport API for iOS keyboard handling
      function _handleVisualViewportChange() {
        _updateControlOffsets();
        if (_mode === 'view') {
          _fitCanvasToParent();
          _drawText();
        }
      }

      window.addEventListener('load', () => { _fitCanvasToParent(); _updateControlOffsets(); });
      window.addEventListener('resize', () => { _fitCanvasToParent(); _updateControlOffsets(); });

      // Add visual viewport support for iOS keyboard
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', _handleVisualViewportChange);
        window.visualViewport.addEventListener('scroll', _handleVisualViewportChange);
      }

      const _onMediaChange = () => {
        _updateControlOffsets();
        _fitCanvasToParent();
        if (_mode === 'view') _drawText();
      };
      if (_mobileQuery.addEventListener) _mobileQuery.addEventListener('change', _onMediaChange);
      else if (_mobileQuery.addListener) _mobileQuery.addListener(_onMediaChange);

      _fitCanvasToParent();
      _enterEdit();
      _runSelfTests();
      _refreshVoices();
      if (!('speechSynthesis' in window)) {
        _btnSpeak.disabled = true;
        _btnSpeak.title = 'Speech synthesis is not supported in this browser.';
      }

      // Register service worker for PWA
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js')
            .then(registration => {
              console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
              console.log('SW registration failed: ', registrationError);
            });
        });
      }
    })();
  </script>
</body>

</html>